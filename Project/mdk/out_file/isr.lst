C251 COMPILER V5.60.0,  isr                                                                11/01/26  21:17:37  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE isr
OBJECT MODULE PLACED IN .\out_file\isr.obj
COMPILER INVOKED BY: D:\Keil\C251\BIN\C251.EXE ..\user\isr.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(SIZE) BROWSE
                    - INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;..\u
                    -ser;..\code) DEBUG PRINT(.\out_file\isr.lst) OBJECT(.\out_file\isr.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2           * STC32G Opensourec Library å³ï¼ˆSTC32G å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬ä¸‰æ–¹å¼€æºå
             -º“
    3           * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4           *
    5           * æœ¬æ–‡ä»¶æ˜¯STC å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6           *
    7           * STC32G å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8           * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®
             -¸å¯è¯ï¼‰çš„æ¡æ¬¾
    9           * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ
             -”¹å®ƒ
   10           *
   11           * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12           * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13           * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14           *
   15           * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16           * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17           *
   18           * é¢å¤–æ³¨æ˜ï¼š
   19           * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20           * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21           * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22           * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ
             -¬å£°æ˜ï¼‰
   23           *
   24           * æ–‡ä»¶åç§°
   25           * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26           * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27           * å¼€å‘ç¯å¢ƒ          MDK FOR C251
   28           * é€‚ç”¨å¹³å°          STC32G
   29           * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30           *
   31           * ä¿®æ”¹è®°å½•
   32           * æ—¥æœŸ              ä½œè€…           å¤‡æ³¨
   33           * 2024-08-01        å¤§W            first version
   34           ********************************************************************************************************
             -************/
   35          
   36          #include "zf_common_headfile.h"
   37          
   38          unsigned char Speed_Flag=0;
   39          unsigned char Angle_Flag=0;
   40          unsigned char Deviation_Flag=0;
   41          unsigned char Uart_Flag=0;
   42          
   43          int Tim1_Count = 0;
   44          
   45          void DMA_UART1_IRQHandler(void) interrupt 4
   46          {
   47   1          static vuint8 dwon_count = 0;
   48   1      
   49   1          if (DMA_UR1R_STA & 0x01) // æ¥æ”¶å®Œæˆ
   50   1          {
   51   2              DMA_UR1R_STA &= ~0x01;      // æ¸…æ ‡å¿—ä½
C251 COMPILER V5.60.0,  isr                                                                11/01/26  21:17:37  PAGE 2   

   52   2              uart_rx_start_buff(UART_1); // è®¾ç½®ä¸‹ä¸€æ¬¡æ¥æ”¶ï¼ŒåŠ¡å¿…ä¿ç•™
   53   2      
   54   2              // ç¨‹åºè‡ªåŠ¨ä¸‹è½½
   55   2              if (uart_rx_buff[UART_1][0] == 0x7F)
   56   2              {
   57   3                  if (dwon_count++ > 20)
   58   3                  {
   59   4                      IAP_CONTR = 0x60;
   60   4                  }
   61   3              }
   62   2              else
   63   2              {
   64   3                  dwon_count = 0;
   65   3              }
   66   2      
   67   2              if (uart1_irq_handler != NULL)
   68   2              {
   69   3                  uart1_irq_handler(uart_rx_buff[UART_1][0]);
   70   3              }
   71   2          }
   72   1      
   73   1          if (DMA_UR1R_STA & 0x02) // æ•°æ®ä¸¢å¼ƒ
   74   1          {
   75   2              DMA_UR1R_STA &= ~0x02;      // æ¸…æ ‡å¿—ä½
   76   2              uart_rx_start_buff(UART_1); // è®¾ç½®ä¸‹ä¸€æ¬¡æ¥æ”¶ï¼ŒåŠ¡å¿…ä¿ç•™
   77   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
   78   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
   79   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
   80   2          }
   81   1      }
   82          
   83          void DMA_UART2_IRQHandler(void) interrupt 8
   84          {
   85   1          if (DMA_UR2R_STA & 0x01) // æ¥æ”¶å®Œæˆ
   86   1          {
   87   2              DMA_UR2R_STA &= ~0x01;      // æ¸…æ ‡å¿—ä½
   88   2              uart_rx_start_buff(UART_2); // è®¾ç½®ä¸‹ä¸€æ¬¡æ¥æ”¶ï¼ŒåŠ¡å¿…ä¿ç•™
   89   2      
   90   2              if (uart2_irq_handler != NULL)
   91   2              {
   92   3                  uart2_irq_handler(uart_rx_buff[UART_2][0]);
   93   3              }
   94   2          }
   95   1      
   96   1          if (DMA_UR2R_STA & 0x02) // æ•°æ®ä¸¢å¼ƒ
   97   1          {
   98   2              DMA_UR2R_STA &= ~0x02;      // æ¸…æ ‡å¿—ä½
   99   2              uart_rx_start_buff(UART_2); // è®¾ç½®ä¸‹ä¸€æ¬¡æ¥æ”¶ï¼ŒåŠ¡å¿…ä¿ç•™
  100   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
  101   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
  102   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
  103   2          }
  104   1      }
  105          
  106          void DMA_UART3_IRQHandler(void) interrupt 17
  107          {
  108   1          if (DMA_UR3R_STA & 0x01) // æ¥æ”¶å®Œæˆ
  109   1          {
  110   2              DMA_UR3R_STA &= ~0x01;      // æ¸…æ ‡å¿—ä½
  111   2              uart_rx_start_buff(UART_3); // è®¾ç½®ä¸‹ä¸€æ¬¡æ¥æ”¶ï¼ŒåŠ¡å¿…ä¿ç•™
  112   2      
  113   2              if (uart3_irq_handler != NULL)
  114   2              {
  115   3                  uart3_irq_handler(uart_rx_buff[UART_3][0]);
  116   3              }
  117   2          }
C251 COMPILER V5.60.0,  isr                                                                11/01/26  21:17:37  PAGE 3   

  118   1      
  119   1          if (DMA_UR3R_STA & 0x02) // æ•°æ®ä¸¢å¼ƒ
  120   1          {
  121   2              DMA_UR3R_STA &= ~0x02;      // æ¸…æ ‡å¿—ä½
  122   2              uart_rx_start_buff(UART_3); // è®¾ç½®ä¸‹ä¸€æ¬¡æ¥æ”¶ï¼ŒåŠ¡å¿…ä¿ç•™
  123   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
  124   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
  125   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
  126   2          }
  127   1      }
  128          
  129          void DMA_UART4_IRQHandler(void) interrupt 18
  130          {
  131   1          if (DMA_UR4R_STA & 0x01) // æ¥æ”¶å®Œæˆ
  132   1          {
  133   2              DMA_UR4R_STA &= ~0x01;      // æ¸…æ ‡å¿—ä½
  134   2              uart_rx_start_buff(UART_4); // è®¾ç½®ä¸‹ä¸€æ¬¡æ¥æ”¶ï¼ŒåŠ¡å¿…ä¿ç•™
  135   2      
  136   2              if (uart4_irq_handler != NULL)
  137   2              {
  138   3                  uart4_irq_handler(uart_rx_buff[UART_4][0]);
  139   3              }
  140   2          }
  141   1      
  142   1          if (DMA_UR4R_STA & 0x02) // æ•°æ®ä¸¢å¼ƒ
  143   1          {
  144   2              DMA_UR4R_STA &= ~0x02;      // æ¸…æ ‡å¿—ä½
  145   2              uart_rx_start_buff(UART_4); // è®¾ç½®ä¸‹ä¸€æ¬¡æ¥æ”¶ï¼ŒåŠ¡å¿…ä¿ç•™
  146   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
  147   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
  148   2              // å¦‚æœè¿›å…¥äº†è¿™ä¸ªä¸­æ–­ï¼Œåˆ™ä»£è¡¨UARTçš„æ•°æ®åœ¨æ²¡æœ‰å–èµ°ä¹‹å‰è¢«è¦†ç›–!
  149   2          }
  150   1      }
  151          
  152          void TM0_IRQHandler() interrupt 1
  153          {
  154   1          TIM0_CLEAR_FLAG;
  155   1      
  156   1          if (tim0_irq_handler != NULL)
  157   1          {
  158   2              tim0_irq_handler();
  159   2          }
  160   1      }
  161          
  162          void TM1_IRQHandler() interrupt 3
  163          {
  164   1          
  165   1              TIM1_CLEAR_FLAG;
  166   1      
  167   1          if (tim1_irq_handler != NULL)
  168   1          {
  169   2              tim1_irq_handler();
  170   2          }
  171   1      }
  172          
  173          void TM2_IRQHandler() interrupt 12
  174          {
  175   1          TIM2_CLEAR_FLAG;
  176   1      
  177   1          if (tim2_irq_handler != NULL)
  178   1          {
  179   2              tim2_irq_handler();
  180   2          }
  181   1      }
  182          
  183          void TM3_IRQHandler() interrupt 19
C251 COMPILER V5.60.0,  isr                                                                11/01/26  21:17:37  PAGE 4   

  184          {
  185   1          TIM3_CLEAR_FLAG;
  186   1      
  187   1          if (tim3_irq_handler != NULL)
  188   1          {
  189   2              tim3_irq_handler();
  190   2          }
  191   1      }
  192          
  193          void TM4_IRQHandler() interrupt 20
  194          {
  195   1          TIM4_CLEAR_FLAG;
  196   1      
  197   1          if (tim4_irq_handler != NULL)
  198   1          {
  199   2              tim4_irq_handler();
  200   2          }
  201   1      }
  202          
  203          
  204          //#define     INT0_VECTOR             0       //0003H
  205          //#define     TMR0_VECTOR             1       //000BH
  206          //#define     INT1_VECTOR             2       //0013H
  207          //#define     TMR1_VECTOR             3       //001BH
  208          //#define     UART1_VECTOR            4       //0023H
  209          //#define     ADC_VECTOR              5       //002BH
  210          //#define     LVD_VECTOR              6       //0033H
  211          ////#define   PCA_VECTOR              7       //003BH
  212          //#define     UART2_VECTOR            8       //0043H
  213          //#define     SPI_VECTOR              9       //004BH
  214          //#define     INT2_VECTOR             10      //0053H
  215          //#define     INT3_VECTOR             11      //005BH
  216          //#define     TMR2_VECTOR             12      //0063H
  217          //#define     USER_VECTOR             13      //006BH
  218          //#define     BRK_VECTOR              14      //0073H
  219          //#define     ICEP_VECTOR             15      //007BH
  220          //#define     INT4_VECTOR             16      //0083H
  221          //#define     UART3_VECTOR            17      //008BH
  222          //#define     UART4_VECTOR            18      //0093H
  223          //#define     TMR3_VECTOR             19      //009BH
  224          //#define     TMR4_VECTOR             20      //00A3H
  225          //#define     CMP_VECTOR              21      //00ABH
  226          ////#define   PWM_VECTOR              22      //00B3H
  227          ////#define   PWMFD_VECTOR            23      //00BBH
  228          //#define     I2C_VECTOR              24      //00C3H
  229          //#define     USB_VECTOR              25      //00CBH
  230          //#define     PWMA_VECTOR             26      //00D3H
  231          //#define     PWMB_VECTOR             27      //00DBH
  232          //#define     CAN1_VECTOR             28      //00E3H
  233          //#define     CAN2_VECTOR             29      //00EBH
  234          //#define     LIN_VECTOR              30      //00F3H
  235          
  236          //#define     RTC_VECTOR              36      //0123H
  237          //#define     P0INT_VECTOR            37      //012BH
  238          //#define     P1INT_VECTOR            38      //0133H
  239          //#define     P2INT_VECTOR            39      //013BH
  240          //#define     P3INT_VECTOR            40      //0143H
  241          //#define     P4INT_VECTOR            41      //014BH
  242          //#define     P5INT_VECTOR            42      //0153H
  243          //#define     P6INT_VECTOR            43      //015BH
  244          //#define     P7INT_VECTOR            44      //0163H
  245          //#define     DMA_M2M_VECTOR          47      //017BH
  246          //#define     DMA_ADC_VECTOR          48      //0183H
  247          //#define     DMA_SPI_VECTOR          49      //018BH
  248          //#define     DMA_UR1T_VECTOR         50      //0193H
  249          //#define     DMA_UR1R_VECTOR         51      //019BH
C251 COMPILER V5.60.0,  isr                                                                11/01/26  21:17:37  PAGE 5   

  250          //#define     DMA_UR2T_VECTOR         52      //01A3H
  251          //#define     DMA_UR2R_VECTOR         53      //01ABH
  252          //#define     DMA_UR3T_VECTOR         54      //01B3H
  253          //#define     DMA_UR3R_VECTOR         55      //01BBH
  254          //#define     DMA_UR4T_VECTOR         56      //01C3H
  255          //#define     DMA_UR4R_VECTOR         57      //01CBH
  256          //#define     DMA_LCM_VECTOR          58      //01D3H
  257          //#define     LCM_VECTOR              59      //01DBH
  258          //#define     DMA_I2CT_VECTOR         60      //01E3H
  259          //#define     DMA_I2CR_VECTOR         61      //01EBH
  260          //#define     I2S_VECTOR              62      //01F3H
  261          //#define     DMA_I2ST_VECTOR         63      //01FBH
  262          //#define     DMA_I2SR_VECTOR         64      //0203H


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       851     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =         7     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        37     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
